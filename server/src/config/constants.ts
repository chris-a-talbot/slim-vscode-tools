// ============================================================================
// CONSTANTS
// This file contains general constants for the language server.
// ============================================================================

import { CompletionItemKind } from 'vscode-languageserver/node';

// VS Code Language Server completion item kinds.
export const COMPLETION_KINDS = {
    METHOD: CompletionItemKind.Method,      // 2
    FUNCTION: CompletionItemKind.Function,  // 3
    CLASS: CompletionItemKind.Class,        // 7
    PROPERTY: CompletionItemKind.Property,  // 10
    SYMBOL: CompletionItemKind.Function     // 12 (for document symbols)
} as const;

// Valid Eidos/SLiM type names.
export const SLIM_TYPES: readonly string[] = [
    'void', 'integer', 'float', 'string', 'logical',
    'object', 'numeric', 'NULL', 'INF'
];

// Diagnostic source identifier for all diagnostics generated by this server.
export const DIAGNOSTIC_SOURCE = 'slim-tools';

// ============================================================================
// PARSING CONSTANTS
// ============================================================================

// Character offsets for string/position calculations
export const CHAR_OFFSETS = {
    AFTER_DOT: 1,           // Position after dot in method calls
    AFTER_OPEN_PAREN: 1,    // Position after opening parenthesis
    AFTER_COMMA: 1,         // Position after comma
    QUOTE_LENGTH: 2,        // Length of quoted string (opening + closing quotes)
    SKIP_OPEN_QUOTE: 1,      // Skip opening quote when calculating position
    SKIP_CLOSE_QUOTE: 1     // Skip closing quote when calculating position
} as const;

// Array/string indices
export const INDICES = {
    FIRST: 0,
    SECOND: 1,
    THIRD: 2
} as const;

// Lookahead limits for multi-line parsing
export const LOOKAHEAD_LIMITS = {
    CONSTANT_VALUE: 3,      // Lines to look ahead for constant values
    CONTEXT_WINDOW: 5       // Characters before/after for context checking
} as const;

// Default positions for diagnostics
export const DEFAULT_POSITIONS = {
    START_OF_LINE: 0,
    START_OF_FILE: 0,
    INVALID: -1
} as const;

// Depth/balance initial values
export const INITIAL_DEPTHS = {
    PARENTHESIS: 0,
    BRACE: 0,
    ARGUMENT: 0,
    FUNCTION_CALL: 1
} as const;

// Parameter index offset (for 1-based display)
export const PARAMETER_INDEX_OFFSET = 1;

/**
 * SLiM/Eidos class names.
 */
export const CLASS_NAMES = {
    SPECIES: 'Species',
    COMMUNITY: 'Community',
    INDIVIDUAL: 'Individual',
    HAPLOSOME: 'Haplosome',
    MUTATION: 'Mutation',
    CHROMOSOME: 'Chromosome',
    SUBPOPULATION: 'Subpopulation',
    MUTATION_TYPE: 'MutationType',
    GENOMIC_ELEMENT_TYPE: 'GenomicElementType',
    INTERACTION_TYPE: 'InteractionType',
    LOGFILE: 'LogFile',
    DICTIONARY: 'Dictionary',
    SLIMEIDOS_BLOCK: 'SLiMEidosBlock'
} as const;

/**
 * Type names for type inference and validation.
 */
export const TYPE_NAMES = {
    INTEGER: 'integer',
    FLOAT: 'float',
    STRING: 'string',
    LOGICAL: 'logical',
    OBJECT: 'object',
    NUMERIC: 'numeric',
    NULL: 'NULL',
    INF: 'INF',
    VOID: 'void'
} as const;

/**
 * Control flow keywords.
 */
export const CONTROL_FLOW_KEYWORDS: readonly string[] = [
    'if', 'else', 'while', 'for', 'do', 'return', 'break', 'continue',
    'switch', 'case', 'default', 'function', 'in', 'next'
];

/**
 * SLiM callback names.
 */
export const CALLBACK_NAMES: readonly string[] = [
    'initialize', 'mutationEffect', 'fitnessEffect', 'mateChoice',
    'modifyChild', 'recombination', 'interaction', 'reproduction',
    'mutation', 'survival', 'early', 'late', 'first'
];

/**
 * Eidos event names.
 */
export const EIDOS_EVENT_NAMES: readonly string[] = ['early', 'late', 'first'];

/**
 * SLiM keywords that are reserved and cannot be used as identifiers.
 */
export const SLIM_KEYWORDS: readonly string[] = [
    'initialize', 'early', 'late', 'fitness', 'interaction',
    'mateChoice', 'modifyChild', 'mutation', 'recombination'
];

/**
 * Built-in SLiM/Eidos reserved identifiers.
 */
export const RESERVED_IDENTIFIERS = new Set<string>([
    'sim', 'community', 'species', 'function', 'void', 'integer', 'float',
    'string', 'logical', 'object', 'numeric', 'NULL', 'INF', 'T', 'F',
    'if', 'else', 'while', 'for', 'return', 'break', 'continue', 'switch',
    'case', 'default', 'initialize', 'early', 'late', 'fitness', 'interaction',
    'mateChoice', 'modifyChild', 'mutation', 'recombination', 'reproduction',
    'survival', 'first', 'this', 'self'
]);

/** 
 * Common SLiM/Eidos function name prefixes.
 */
export const FUNCTION_PREFIXES: readonly string[] = [
    'initialize', 'mm', 'nucleotide', 'codon', 'remove', 'define', 'sample',
    'point', 'deviate', 'parallel', 'read', 'write', 'output', 'treeSeq',
    'get', 'is', 'as', 'set', 'add', 'spatialMap', 'calc'
];

/**
 * Type for class name values
 */
export type ClassName = typeof CLASS_NAMES[keyof typeof CLASS_NAMES];

/**
 * Type for type name values
 */
export type TypeName = typeof TYPE_NAMES[keyof typeof TYPE_NAMES];

// ============================================================================
// ERROR AND WARNING MESSAGES
// Centralized error and warning messages used throughout the language server.
// ============================================================================

/**
 * Error messages for validation diagnostics.
 */
export const ERROR_MESSAGES = {
    // Brace errors
    UNEXPECTED_CLOSING_BRACE: 'Unexpected closing brace',
    UNCLOSED_BRACE: 'Unclosed brace(s)',
    
    // Semicolon warnings
    MISSING_SEMICOLON: 'Statement might be missing a semicolon',
    
    // String errors
    UNCLOSED_STRING: 'Unclosed string literal (missing closing quote)',
    
    // Event errors
    NO_EIDOS_EVENT: 'No Eidos event found to start the simulation. At least one first(), early(), or late() event is required.',
    OLD_SYNTAX: 'Event type must be specified explicitly. Use "1 early() { ... }" instead of "1 { ... }"',
    EVENT_PARAMETERS: (eventName: string) => `${eventName}() event needs 0 parameters`,
    
    // Definition errors
    DUPLICATE_DEFINITION: (typeName: string, id: string, firstLine: number) => `${typeName} ${id} already defined (first defined at line ${firstLine})`,
    RESERVED_IDENTIFIER: (id: string, context?: string) => `Identifier '${id}' is reserved and cannot be used${context ? ` for ${context}` : ''}`,
    RESERVED_SPECIES_NAME: (name: string) => `Species name '${name}' is reserved and cannot be used`,
    
    // Method and property errors
    METHOD_NOT_EXISTS: (methodName: string, className: string) => `Method '${methodName}' does not exist on ${className}`,
    PROPERTY_NOT_EXISTS: (propertyName: string, className: string) => `Property '${propertyName}' does not exist on ${className}`,
    
    // Function call errors
    FUNCTION_NOT_FOUND: (funcName: string) => `Function '${funcName}' not found in SLiM/Eidos documentation`,
    
    // NULL assignment errors
    NULL_TO_NON_NULLABLE: (paramName: string, typeName: string, context?: string) => {
        const contextStr = context ? ` in ${context}` : '';
        return `NULL cannot be passed to non-nullable parameter '${paramName}' of type '${typeName}'${contextStr}`;
    },
    
    // Reference warnings
    UNDEFINED_REFERENCE: (typeName: string, id: string) => `${typeName} ${id} may not be defined in the focal species`
} as const;

/**
 * Type names for error messages.
 */
export const TYPE_NAMES_FOR_ERRORS = {
    MUTATION_TYPE: 'Mutation type',
    GENOMIC_ELEMENT_TYPE: 'Genomic element type',
    INTERACTION_TYPE: 'Interaction type',
    SUBPOPULATION: 'Subpopulation',
    SPECIES: 'Species',
    CONSTANT: 'Constant',
    SCRIPT_BLOCK: 'Script block'
} as const;

/**
 * Context strings for reserved identifier errors.
 */
export const RESERVED_IDENTIFIER_CONTEXTS = {
    GLOBAL_CONSTANT: 'a global constant',
    SPECIES_NAME: 'a species name'
} as const;

// ============================================================================
// CALLBACK HANDLING
// ============================================================================

/**
 * Tick cycle information for events and callbacks in WF and nonWF models.
 * This provides quick reference for when each event/callback executes.
 */
export interface TickCycleInfo {
    wf: string;
    nonwf: string;
}

/**
 * Pseudo-parameters available in each callback type.
 * These are special variables that SLiM provides within callback contexts.
 * Key format: callback name (e.g., "mutationEffect()", "reproduction()")
 * Value: object mapping parameter name to Eidos type
 */
export const CALLBACK_PSEUDO_PARAMETERS: Readonly<Record<string, Record<string, string>>> = {
    'initialize()': {},
    'mutationEffect()': {
        'mut': CLASS_NAMES.MUTATION,
        'homozygous': TYPE_NAMES.LOGICAL,
        'effect': TYPE_NAMES.FLOAT
    },
    'fitnessEffect()': {
        'individual': CLASS_NAMES.INDIVIDUAL,
        'subpop': CLASS_NAMES.SUBPOPULATION
    },
    'mateChoice()': {
        'sourceSubpop': CLASS_NAMES.SUBPOPULATION,
        'weights': TYPE_NAMES.FLOAT,
        'individual': CLASS_NAMES.INDIVIDUAL,
        'subpop': CLASS_NAMES.SUBPOPULATION
    },
    'modifyChild()': {
        'child': CLASS_NAMES.INDIVIDUAL,
        'isCloning': TYPE_NAMES.LOGICAL,
        'isSelfing': TYPE_NAMES.LOGICAL,
        'parent1': CLASS_NAMES.INDIVIDUAL,
        'parent2': CLASS_NAMES.INDIVIDUAL,
        'sourceSubpop': CLASS_NAMES.SUBPOPULATION
    },
    'recombination()': {
        'haplosome1': CLASS_NAMES.HAPLOSOME,
        'haplosome2': CLASS_NAMES.HAPLOSOME,
        'breakpoints': TYPE_NAMES.INTEGER,
        'individual': CLASS_NAMES.INDIVIDUAL,
        'subpop': CLASS_NAMES.SUBPOPULATION
    },
    'interaction()': {
        'distance': TYPE_NAMES.FLOAT,
        'strength': TYPE_NAMES.FLOAT,
        'receiver': CLASS_NAMES.INDIVIDUAL,
        'exerter': CLASS_NAMES.INDIVIDUAL
    },
    'reproduction()': {
        'individual': CLASS_NAMES.INDIVIDUAL,
        'subpop': CLASS_NAMES.SUBPOPULATION
    },
    'mutation()': {
        'mut': CLASS_NAMES.MUTATION,
        'haplosome': CLASS_NAMES.HAPLOSOME,
        'element': 'GenomicElement',
        'originalNuc': TYPE_NAMES.INTEGER,
        'parent': CLASS_NAMES.INDIVIDUAL,
        'subpop': CLASS_NAMES.SUBPOPULATION
    },
    'survival()': {
        'surviving': TYPE_NAMES.LOGICAL,
        'fitness': TYPE_NAMES.FLOAT,
        'draw': TYPE_NAMES.FLOAT,
        'individual': CLASS_NAMES.INDIVIDUAL,
        'subpop': CLASS_NAMES.SUBPOPULATION
    }
} as const;

/**
 * Tick cycle information for events and callbacks in WF and nonWF models.
 * This provides quick reference for when each event/callback executes.
 */
export const TICK_CYCLE_INFO: Readonly<Record<string, TickCycleInfo>> = {
    'first()': {
        wf: 'Step 0: Executes first in the tick cycle',
        nonwf: 'Step 0: Executes first in the tick cycle'
    },
    'early()': {
        wf: 'Step 1: Executes early in the tick cycle (after first(), before offspring generation)',
        nonwf: 'Step 2: Executes after offspring generation, before fitness calculation'
    },
    'late()': {
        wf: 'Step 5: Executes late in the tick cycle (after offspring become parents)',
        nonwf: 'Step 6: Executes late in the tick cycle (after selection and mutation removal)'
    },
    'initialize()': {
        wf: 'Pre-simulation: Executes before the simulation starts (not part of tick cycle)',
        nonwf: 'Pre-simulation: Executes before the simulation starts (not part of tick cycle)'
    },
    'mutationEffect()': {
        wf: 'Step 3: Called during fitness recalculation (at end of tick, for next tick)',
        nonwf: 'Step 3: Called during fitness recalculation (same tick)'
    },
    'fitnessEffect()': {
        wf: 'Step 3: Called during fitness recalculation (at end of tick, for next tick)',
        nonwf: 'Step 3: Called during fitness recalculation (same tick)'
    },
    'mateChoice()': {
        wf: 'Step 2.3: Called during offspring generation when choosing parent 2',
        nonwf: 'N/A: Not used in nonWF models (mating is script-controlled)'
    },
    'modifyChild()': {
        wf: 'Step 2.5: Called during offspring generation to suppress/modify child',
        nonwf: 'Step 1.4: Called during offspring generation to suppress/modify child'
    },
    'mutation()': {
        wf: 'Step 2.4: Called during offspring generation when mutations are created',
        nonwf: 'Step 1.3: Called during offspring generation when mutations are created'
    },
    'recombination()': {
        wf: 'Step 2.4: Called during offspring generation when gametes are created',
        nonwf: 'Step 1.3: Called during offspring generation when gametes are created'
    },
    'reproduction()': {
        wf: 'N/A: Not used in WF models (reproduction is automatic)',
        nonwf: 'Step 1.1: Called to trigger reproduction (script-controlled)'
    },
    'survival()': {
        wf: 'N/A: Not used in WF models (parents always die)',
        nonwf: 'Step 4: Called during selection phase to determine survival'
    },
    'interaction()': {
        wf: 'On-demand: Called when interaction strengths are evaluated (various points)',
        nonwf: 'On-demand: Called when interaction strengths are evaluated (various points)'
    }
} as const;

